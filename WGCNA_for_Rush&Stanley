#20190306
#看两套数据的重复
#取重复的9000+基因来做

library(WGCNA)
library(preprocessCore)
options(stringsAsFactors = FALSE)

setwd("Jiacheng/agonal-state/1217newest/0306")
b<-read.csv("1.csv",header=T,row.names=1)
sample2<-read.csv("sample537.csv",header=T,row.names=1)
a<-load("agonalstate_1217.RData")
samplerush<-sample2[colnames(b),]
datrush<-b
datstanley<-t(datExpr)
samplestanley<-sample
c<-intersect(rownames(datstanley),rownames(datrush))
#共有的基因数只有9943
#有必要用overlap基因之后的数据来重做一次吗
save(datstanley,datrush,samplestanley,samplerush,file="data0306.RData")
c<-intersect(rownames(datstanley),rownames(datrush))
length(c)
#[1] 9943
datstanley2<-datstanley[c,]
datrush2<-datrush[c,]

#现在的数据都是经过了校正的
#stanley的数据是"stanley.r"里面做完WGCNA的存档
#rush的数据是做细胞类型富集的时候存的1.csv，也是做完了WGCNA的结果
#那么就直接上WGCNA了
#冲！

#WGCNA-rush
enableWGCNAThreads()
powers = c(c(1:10), seq(from = 12, to=20, by=2))
sft = pickSoftThreshold(t(datrush2), powerVector = powers, networkType="signed", verbose = 5)
pdf("powerselect_rush.pdf")
par(mfrow = c(1,2))
cex1 = 0.9
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",main = paste("Scale independence"))
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],labels=powers,cex=cex1,col="red")
abline(h=0.90,col="red")
plot(sft$fitIndices[,1], sft$fitIndices[,5],xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
dev.off()

netrush<- blockwiseModules(t(datrush2), power = 14, networkType = "signed", TOMType ="unsigned", corType="pearson", maxBlockSize=20000, maxModuleSize =4000, minModuleSize =30, reassignThreshold = 0, mergeCutHeight = 0.25, numericLabels = TRUE, pamRespectsDendro = FALSE, saveTOMs = TRUE, saveTOMFileBase ="agonal_rush" , verbose = 3)
table(netrush$colors)
moduleLabelsrush = netrush$colors
moduleColorsrush = labels2colors(netrush$colors)
MEsrush = netrush$MEs
geneTreerush = netrush$dendrograms[[1]]
save(MEsrush, moduleLabelsrush, moduleColorsrush, geneTreerush, datrush2, netrush, file="net_rush0307.RData")

pdf("WGCNA-rush.pdf")
plotDendroAndColors(netrush$dendrograms[[1]], moduleColorsrush[netrush$blockGenes[[1]]],
                    "Module colors",
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05)
dev.off()

table<-netrush$colors
informatio<-data.frame(gene=rownames(datrush2),module=table,color=labels2colors(netrush$colors))
dim(informatio)
write.csv(informatio,file="geneinfo-rush.csv")

nGenes=nrow(datrush2)
nSamples=ncol(datrush2)
MEs0 = moduleEigengenes(t(datrush2), moduleColorsrush)$eigengenes
MEs = orderMEs(MEs0)
geneModulesMembership=as.data.frame(cor(t(datrush2),MEs,use="p"))
MMPvalue=as.data.frame(corPvalueStudent(as.matrix(geneModulesMembership),nSamples))
write.csv(MMPvalue,file="MMPvalue-rush.csv")
write.csv(geneModulesMembership,file="MM-rush.csv")

corrush=cor(MEs,samplerush,use="p")
prush=corPvalueFisher(corrush,nSamples)
q<-p.adjust(prush,method="fdr")
dim(q)<-dim(prush)
dimnames(q)<-dimnames(prush)

textMatrix =  paste(signif(corrush, 2), "\n(",
                           signif(q, 1), ")", sep = "")
pdf("heatmap-rush.pdf")
par(mar = c(6, 8.5, 3, 3))
labeledHeatmap(Matrix = corrush,
               xLabels = names(samplerush),
               yLabels = names(MEs),
               ySymbols = names(MEs),
               colorLabels = FALSE,
               colors = greenWhiteRed(50),
               textMatrix = textMatrix,
               setStdMargins = FALSE,
               cex.text = 0.5,
               zlim = c(-1,1),
               main = paste("Module-trait relationships"))
dev.off()


#WGCNA-stanley
enableWGCNAThreads()
powers = c(c(1:10), seq(from = 12, to=20, by=2))
sft = pickSoftThreshold(t(datstanley2), powerVector = powers, networkType="signed", verbose = 5)
pdf("powerselect_stanley.pdf")
par(mfrow = c(1,2))
cex1 = 0.9
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",main = paste("Scale independence"))
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],labels=powers,cex=cex1,col="red")
abline(h=0.90,col="red")
plot(sft$fitIndices[,1], sft$fitIndices[,5],xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
dev.off()

netstanley<- blockwiseModules(t(datstanley2), power = 2, networkType = "signed", TOMType ="unsigned", corType="pearson", maxBlockSize=20000, maxModuleSize =4000, minModuleSize =30, reassignThreshold = 0, mergeCutHeight = 0.25, numericLabels = TRUE, pamRespectsDendro = FALSE, saveTOMs = TRUE, saveTOMFileBase ="agonal_stanley" , verbose = 3)
table(netstanley$colors)
moduleLabelsstanley = netstanley$colors
moduleColorsstanley = labels2colors(netstanley$colors)
MEsstanley = netstanley$MEs
geneTreestanley = netstanley$dendrograms[[1]]
save(MEsstanley, moduleLabelsstanley, moduleColorsstanley, geneTreestanley, datstanley2, netstanley, file="net_stanley0307.RData")

pdf("WGCNA-stanley.pdf")
plotDendroAndColors(netstanley$dendrograms[[1]], moduleColorsstanley[netstanley$blockGenes[[1]]],
                    "Module colors",
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05)
dev.off()

table<-netstanley$colors
informatio<-data.frame(gene=rownames(datstanley2),module=table,color=labels2colors(netstanley$colors))
dim(informatio)
write.csv(informatio,file="geneinfo-stanley.csv")

nGenes=nrow(datstanley2)
nSamples=ncol(datstanley2)
MEs0 = moduleEigengenes(t(datstanley2), moduleColorsstanley)$eigengenes
MEs = orderMEs(MEs0)
geneModulesMembership=as.data.frame(cor(t(datstanley2),MEs,use="p"))
MMPvalue=as.data.frame(corPvalueStudent(as.matrix(geneModulesMembership),nSamples))
write.csv(MMPvalue,file="MMPvalue-stanley.csv")
write.csv(geneModulesMembership,file="MM-stanley.csv")

corstanley=cor(MEs,samplestanley,use="p")
pstanley=corPvalueFisher(corstanley,nSamples)
q<-p.adjust(pstanley,method="fdr")
dim(q)<-dim(pstanley)
dimnames(q)<-dimnames(pstanley)

textMatrix =  paste(signif(corstanley, 2), "\n(",
                           signif(pstanley, 1), ")", sep = "")
pdf("heatmap-stanley.pdf")
par(mar = c(6, 8.5, 3, 3))
labeledHeatmap(Matrix = corstanley,
               xLabels = names(samplestanley),
               yLabels = names(MEs),
               ySymbols = names(MEs),
               colorLabels = FALSE,
               colors = greenWhiteRed(50),
               textMatrix = textMatrix,
               setStdMargins = FALSE,
               cex.text = 0.5,
               zlim = c(-1,1),
               main = paste("Module-trait relationships"))
dev.off()

#模块基因比较
a<-load("net_rush0307.RData")
b<-load("net_stanley0307.RData")
Labels_rush = moduleLabelsrush
Colors_rush = moduleColorsrush
Tree_rush = geneTreerush
me_rush = orderMEs(MEsrush, greyName = "ME0")

Labels_stanley = moduleLabelsstanley
Colors_stanley = moduleColorsstanley
Tree_stanley = geneTreestanley
me_stanley = orderMEs(MEsstanley, greyName = "ME0")

me_rush_modulelabels=substring(names(me_rush),3)
me_stanley_modulelabels=substring(names(me_stanley),3)

modules_rush = labels2colors(as.numeric(me_rush_modulelabels))
modules_stanley = labels2colors(as.numeric(me_stanley_modulelabels))

n_rush = length(modules_rush)
n_stanley = length(modules_stanley)

pTable = matrix(0, nrow = n_rush, ncol = n_stanley)
countbl = matrix(0, nrow = n_rush, ncol = n_stanley)

for (fmod in 1:n_rush) 
  for (cmod in 1:n_stanley)
  {
    femMembers = (Colors_rush == modules_rush[fmod]);
    consMembers =(Colors_stanley == modules_stanley[cmod])
    pTable[fmod, cmod] = -log10(fisher.test(femMembers, consMembers, alternative = "greater")$p.value);
    countbl[fmod, cmod] = sum(Colors_rush == modules_rush[fmod] & Colors_stanley == modules_stanley[cmod])
  }

pTable[is.infinite(pTable)] = 1.3*max(pTable[is.finite(pTable)])
pTable[pTable>50 ] = 50

modtotals_rush=apply(countbl,1,sum)
modtotals_stanley=apply(countbl,2,sum)

pdf(file="plotconsensusmodule0307.pdf")
par(mfrow=c(1,1))
par(cex = 1.0)
par(mar=c(8, 10.4, 2.7, 1)+0.3)

labeledHeatmap(Matrix = pTable,
xLabels = paste(" ", modules_stanley),
yLabels = paste(" ", modules_rush),
colorLabels = TRUE,
xSymbols = paste("stanley", modules_stanley, ": ", modtotals_stanley, sep=""),
ySymbols = paste("rush ", modules_rush, ": ", modtotals_rush, sep=""),
textMatrix = countbl,
colors = greenWhiteRed(100)[50:100],
main = "module_rush&module_stanley",
cex.text = 1.0,
cex.lab = 1.0,
setStdMargins = FALSE)

dev.off()
#重复的结果还蛮好的
#接下来看rush的cell type
library(gplots)
library(pSI)
colors = vector(mode="list")
colors<-moduleColorsrush
MEs = moduleEigengenes(expr = t(datrush2), colors, softPower = 14)
eigmat = MEs$eigengenes
colnames(eigmat) = gsub("ME","",colnames(eigmat))


zhang.datExpr = read.csv("datExpr.zhangHuman.avgForPSI.csv",row.names=1)[,-1]
set.seed(100)
pSI.output = specificity.index(pSI.in=zhang.datExpr,bts=100,p_max=.1, e_min=0.3) 
pSI.count(pSI.output)

cell.p.zhang = matrix(NA, 13,5)
rownames(cell.p.zhang) = unique(colors)
colnames(cell.p.zhang) = colnames(pSI.output)

for(mod in rownames(cell.p.zhang)) {
    f = fisher.iteration(pSI.output, rownames(datrush2)[colors==mod],p.adjust = F)
    cell.p.zhang[mod,] = f$`0.05 - nominal`
}

cell.p.zhang.fdr = p.adjust(cell.p.zhang,"fdr")
dim(cell.p.zhang.fdr) = dim(cell.p.zhang)
dimnames(cell.p.zhang.fdr) = dimnames(cell.p.zhang);
to_plot = cell.p.zhang.fdr[c("turquoise", "yellow", "blue", "brown", "tan","pink","black","purple","red","greenyellow","green","magenta","grey"),]


dendro.col = as.dendrogram(hclust(as.dist(1-bicor(zhang.datExpr)), method="average"))
denro.row= as.dendrogram(hclust(as.dist(1-bicor(eigmat[,c("turquoise", "yellow", "blue", "brown", "tan","pink","black","purple","red","greenyellow","green","magenta","grey")])),method="average"))

pdf("CellType-rush0307.pdf",width=6,height=5)
heatmap.2(-log10(to_plot),col=blueWhiteRed(1000,1)[500:1000],
          scale="none",trace="none",cexRow = 0.8,cexCol = .8, density.info = "none",
          colsep=0:7,rowsep=0:8,sepcolor="grey",sepwidth=c(0.02,0.02),
          srtCol=45,offsetRow=0,offsetCol=-0.5,
          Rowv=denro.row, Colv=dendro.col,
          key=T,key.xlab="-log10(P)", cellnote=signif(to_plot,1), notecex=.8, notecol="black",main="Enrichment")
dev.off()

#stanley的cell type
colors = vector(mode="list")
colors<-moduleColorsstanley
MEs = moduleEigengenes(expr = t(datstanley2), colors, softPower = 2)
eigmat = MEs$eigengenes
colnames(eigmat) = gsub("ME","",colnames(eigmat))


zhang.datExpr = read.csv("datExpr.zhangHuman.avgForPSI.csv",row.names=1)[,-1]
set.seed(100)
pSI.output = specificity.index(pSI.in=zhang.datExpr,bts=100,p_max=.1, e_min=0.3) 
pSI.count(pSI.output)

cell.p.zhang = matrix(NA, 6,5)
rownames(cell.p.zhang) = unique(colors)
colnames(cell.p.zhang) = colnames(pSI.output)

for(mod in rownames(cell.p.zhang)) {
    f = fisher.iteration(pSI.output, rownames(datstanley2)[colors==mod],p.adjust = F)
    cell.p.zhang[mod,] = f$`0.05 - nominal`
}

cell.p.zhang.fdr = p.adjust(cell.p.zhang,"fdr")
dim(cell.p.zhang.fdr) = dim(cell.p.zhang)
dimnames(cell.p.zhang.fdr) = dimnames(cell.p.zhang);
to_plot = cell.p.zhang.fdr[c("turquoise", "yellow", "blue", "brown", "green","grey"),]


dendro.col = as.dendrogram(hclust(as.dist(1-bicor(zhang.datExpr)), method="average"))
denro.row= as.dendrogram(hclust(as.dist(1-bicor(eigmat[,c("turquoise", "yellow", "blue", "brown", "green","grey")])),method="average"))

pdf("CellType-stanley0307.pdf",width=6,height=5)
heatmap.2(-log10(to_plot),col=blueWhiteRed(1000,1)[500:1000],
          scale="none",trace="none",cexRow = 0.8,cexCol = .8, density.info = "none",
          colsep=0:7,rowsep=0:8,sepcolor="grey",sepwidth=c(0.02,0.02),
          srtCol=45,offsetRow=0,offsetCol=-0.5,
          Rowv=denro.row, Colv=dendro.col,
          key=T,key.xlab="-log10(P)", cellnote=signif(to_plot,1), notecex=.8, notecol="black",main="Enrichment")
dev.off()

#modulePreservation  #用邻接矩阵做modulePreservation，如果用表达矩阵做会有bug（不是我做错的）
#multiExpr是邻接矩阵用list连接起来，multiColor是reference的moduleColor

load("net_rush0307.RData")
load("net_stanley0307.RData")
#1
setLabels<-c("Stanley","Rush")
multiExpr<-list(Stanley=list(data=t(datstanley2)),Rush=list(data=t(datrush2)))
multiColor<-list(Stanley=moduleColorsstanley)
#2
setLabels<-c("Rush","Stanley")
multiExpr<-list(Rush=list(data=t(datrush2)),Stanley=list(data=t(datstanley2)))
multiColor<-list(Rush=moduleColorsrush)

mp = modulePreservation(multiExpr, multiColor, dataIsExpr = TRUE, networkType = "signed", corFnc = "cor", corOptions = "use = 'p'", referenceNetworks = 1, testNetworks = NULL, nPermutations = 200, includekMEallInSummary = FALSE, restrictSummaryForGeneralNetworks = TRUE, calculateQvalue = FALSE, randomSeed = 12345, maxGoldModuleSize = 1000, maxModuleSize = 1000, quickCor = 1, verbose=3)

ref=1
test=2
statsObs=cbind(mp$quality$observed[[ref]][[test]][,-1],mp$preservation$observed[[ref]][[test]][,-1])
statsZ=cbind(mp$quality$Z[[ref]][[test]][,-1],mp$preservation$Z[[ref]][[test]][,-1])
print(cbind(statsObs[,c("medianRank.pres","medianRank.qual")],signif(statsZ[,c("Zsummary.pres","Zsummary.qual")],2)))
stats=cbind(statsObs[,c("medianRank.pres","medianRank.qual")],signif(statsZ[,c("Zsummary.pres","Zsummary.qual")],2))
modColors=rownames(mp$preservation$observed[[ref]][[test]])
moduleSizes=mp$preservation$Z[[ref]][[test]][,1]
row.names(statsZ[stats$Zsummary.pres<10,])

#去掉Z<10的module
plotMods=!(modColors %in% row.names(statsZ[stats$Zsummary.pres<0,]))
text=modColors[plotMods]
plotData=cbind(mp$preservation$observed[[ref]][[test]][,2],mp$preservation$Z[[ref]][[test]][,2])
#可视化
mains = c("Preservation Median rank", "Preservation Zsummary")
sizeGrWindow(10, 5)
#分别把两个数据集作为背景的图
pdf("preservation1.pdf",width=20,height=10)
pdf("preservation2.pdf",width=20,height=10)
par(mfrow = c(1,2))
par(mar = c(4.5,4.5,2.5,1))
for (p in 1:2){
  min = min(plotData[, p], na.rm = TRUE)
  max = max(plotData[, p], na.rm = TRUE)
    if (p==2){ 
		if (min > -max/10) min = -max/10 
		ylim = c(min - 0.1 * (max-min), max + 0.1 * (max-min)) 
		} else 
		ylim = c(min - 0.1 * (max-min), max + 0.1 * (max-min))
	 plot(moduleSizes[plotMods], plotData[plotMods, p], col = 1, bg = modColors[plotMods], pch = 21, main = mains[p], cex=2.4, ylab = mains[p], xlab = "Module size", log = "x",ylim=ylim, xlim=c(10,2000), cex.lab=1.2, cex.axis=1.2,cex.main=1.4)
	 labelPoints(moduleSizes[plotMods], plotData[plotMods, p], text, cex = 1, offs = 0.08)
	if (p==2){
    abline(h=0)
    abline(h=2, col = "blue", lty = 2)
    abline(h=10, col = "darkgreen", lty = 2)
	}
}
dev.off()
